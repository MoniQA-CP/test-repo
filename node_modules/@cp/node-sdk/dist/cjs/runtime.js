"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Channel Payments API
 *
 * NOTE: This class is auto generated. Do not edit the class manually.
 *
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.removeNullUndefined = exports.COLLECTION_FORMATS = exports.RequiredError = exports.FetchError = exports.ResponseError = exports.BaseAPI = void 0;
exports.exists = exists;
exports.querystring = querystring;
exports.mapValues = mapValues;
exports.canConsumeForm = canConsumeForm;
const ENVIRONMENT_URLS = {
    prod: 'https://channelpayments-api.com',
    sandbox: 'https://sandbox.channelpayments-api.com',
};
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const jwt = __importStar(require("jsonwebtoken"));
const ulidx_1 = require("ulidx");
/**
 * This is the base class for all generated API classes.
 */
class BaseAPI {
    constructor(apiConfig) {
        this.apiConfig = apiConfig;
        this.keyId = apiConfig.keyId;
        this.privateKey = apiConfig.privateKey;
        if (apiConfig.url && apiConfig.environment) {
            throw new Error("you must specify either 'url' or 'environment', not both");
        }
        if (apiConfig.url) {
            this.url = apiConfig.url;
        }
        else if (apiConfig.environment) {
            if (!ENVIRONMENT_URLS[apiConfig.environment]) {
                throw new Error(`Unsupported environment '${apiConfig.environment}'. Valid values: 'prod | sandbox'`);
            }
            this.url = ENVIRONMENT_URLS[apiConfig.environment];
        }
        else {
            throw new Error("Expected one of 'environment' or 'url' to be specified");
        }
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        if (!mime) {
            return false;
        }
        return BaseAPI.jsonRegex.test(mime);
    }
    request(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const { url, requestInit } = yield this.createFetchParams(context);
            return yield (0, cross_fetch_1.default)(url, requestInit);
        });
    }
    createFetchParams(context) {
        return __awaiter(this, void 0, void 0, function* () {
            Object.keys(context.headers).forEach(key => context.headers[key] === undefined ? delete context.headers[key] : {});
            context.headers['user-agent'] = "@channelpayments/node-sdk/v1.271.0";
            const token = this.generateAuthToken();
            context.headers['Authorization'] = `Bearer ${token}`;
            let url = this.url + context.path;
            if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                url += '?' + querystring(context.query);
            }
            const requestInit = {
                method: context.method,
                headers: context.headers,
                body: isFormData(context.body) ||
                    context.body instanceof URLSearchParams ||
                    isBlob(context.body)
                    ? context.body
                    : JSON.stringify(context.body),
            };
            return { url, requestInit };
        });
    }
    generateAuthToken() {
        const header = {
            typ: 'JWT',
            alg: 'ES512',
            kid: this.keyId,
        };
        const currentTime = Math.floor(Date.now() / 1000);
        const expirationTime = currentTime + 30; // 30 seconds from now
        const claims = {
            iss: 'channelpayments/node-sdk',
            iat: currentTime,
            exp: expirationTime,
            jti: (0, ulidx_1.ulid)(),
            scopes: ['*.read', '*.write'],
        };
        return jwt.sign(claims, this.privateKey, { algorithm: 'ES512', header });
    }
}
exports.BaseAPI = BaseAPI;
BaseAPI.jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
;
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
function isFormData(value) {
    return typeof FormData !== "undefined" && value instanceof FormData;
}
class ResponseError extends Error {
    constructor(response, msg) {
        super(msg);
        this.response = response;
        this.name = "ResponseError";
    }
}
exports.ResponseError = ResponseError;
class FetchError extends Error {
    constructor(cause, msg) {
        super(msg);
        this.cause = cause;
        this.name = "FetchError";
    }
}
exports.FetchError = FetchError;
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
function exists(json, key) {
    const value = json[key];
    return value !== null && value !== undefined;
}
const removeNullUndefined = (obj) => Object.fromEntries(Object.entries(obj).filter(([_, v]) => v != null));
exports.removeNullUndefined = removeNullUndefined;
function querystring(params, prefix = '') {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}
function querystringSingleKey(key, value, keyPrefix = '') {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
    if (value instanceof Array) {
        return value
            .map((arrayValue, i) => querystringSingleKey(`${key}[${i}]`, arrayValue, keyPrefix))
            .join('&');
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
        return querystring(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function mapValues(data, fn) {
    return Object.keys(data).reduce((acc, key) => (Object.assign(Object.assign({}, acc), { [key]: fn(data[key]) })), {});
}
function canConsumeForm(consumes) {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}
class JSONApiResponse {
    constructor(raw, transformer = (jsonValue) => jsonValue) {
        this.raw = raw;
        this.transformer = transformer;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.transformer(yield this.raw.json());
        });
    }
}
exports.JSONApiResponse = JSONApiResponse;
class VoidApiResponse {
    constructor(raw) {
        this.raw = raw;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return undefined;
        });
    }
}
exports.VoidApiResponse = VoidApiResponse;
class BlobApiResponse {
    constructor(raw) {
        this.raw = raw;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.raw.blob();
        });
    }
    ;
}
exports.BlobApiResponse = BlobApiResponse;
class TextApiResponse {
    constructor(raw) {
        this.raw = raw;
    }
    value() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.raw.text();
        });
    }
    ;
}
exports.TextApiResponse = TextApiResponse;
