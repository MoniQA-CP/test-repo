/* tslint:disable */
/* eslint-disable */
/**
 * Channel Payments API
 *
 * NOTE: This class is auto generated. Do not edit the class manually.
 *
 */
const ENVIRONMENT_URLS = {
    prod: 'https://channelpayments-api.com',
    sandbox: 'https://sandbox.channelpayments-api.com',
};
import fetch from 'cross-fetch';
import * as jwt from 'jsonwebtoken';
import { ulid } from 'ulidx';
/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {
    apiConfig;
    static jsonRegex = new RegExp('^(:?application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$', 'i');
    keyId;
    privateKey;
    url;
    constructor(apiConfig) {
        this.apiConfig = apiConfig;
        this.keyId = apiConfig.keyId;
        this.privateKey = apiConfig.privateKey;
        if (apiConfig.url && apiConfig.environment) {
            throw new Error("you must specify either 'url' or 'environment', not both");
        }
        if (apiConfig.url) {
            this.url = apiConfig.url;
        }
        else if (apiConfig.environment) {
            if (!ENVIRONMENT_URLS[apiConfig.environment]) {
                throw new Error(`Unsupported environment '${apiConfig.environment}'. Valid values: 'prod | sandbox'`);
            }
            this.url = ENVIRONMENT_URLS[apiConfig.environment];
        }
        else {
            throw new Error("Expected one of 'environment' or 'url' to be specified");
        }
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        if (!mime) {
            return false;
        }
        return BaseAPI.jsonRegex.test(mime);
    }
    async request(context) {
        const { url, requestInit } = await this.createFetchParams(context);
        return await fetch(url, requestInit);
    }
    async createFetchParams(context) {
        Object.keys(context.headers).forEach(key => context.headers[key] === undefined ? delete context.headers[key] : {});
        context.headers['user-agent'] = "@channelpayments/node-sdk/v1.271.0";
        const token = this.generateAuthToken();
        context.headers['Authorization'] = `Bearer ${token}`;
        let url = this.url + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
            url += '?' + querystring(context.query);
        }
        const requestInit = {
            method: context.method,
            headers: context.headers,
            body: isFormData(context.body) ||
                context.body instanceof URLSearchParams ||
                isBlob(context.body)
                ? context.body
                : JSON.stringify(context.body),
        };
        return { url, requestInit };
    }
    generateAuthToken() {
        const header = {
            typ: 'JWT',
            alg: 'ES512',
            kid: this.keyId,
        };
        const currentTime = Math.floor(Date.now() / 1000);
        const expirationTime = currentTime + 30; // 30 seconds from now
        const claims = {
            iss: 'channelpayments/node-sdk',
            iat: currentTime,
            exp: expirationTime,
            jti: ulid(),
            scopes: ['*.read', '*.write'],
        };
        return jwt.sign(claims, this.privateKey, { algorithm: 'ES512', header });
    }
}
;
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
function isFormData(value) {
    return typeof FormData !== "undefined" && value instanceof FormData;
}
export class ResponseError extends Error {
    response;
    name = "ResponseError";
    constructor(response, msg) {
        super(msg);
        this.response = response;
    }
}
export class FetchError extends Error {
    cause;
    name = "FetchError";
    constructor(cause, msg) {
        super(msg);
        this.cause = cause;
    }
}
export class RequiredError extends Error {
    field;
    name = "RequiredError";
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
export function exists(json, key) {
    const value = json[key];
    return value !== null && value !== undefined;
}
export const removeNullUndefined = (obj) => Object.fromEntries(Object.entries(obj).filter(([_, v]) => v != null));
export function querystring(params, prefix = '') {
    return Object.keys(params)
        .map(key => querystringSingleKey(key, params[key], prefix))
        .filter(part => part.length > 0)
        .join('&');
}
function querystringSingleKey(key, value, keyPrefix = '') {
    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
    if (value instanceof Array) {
        return value
            .map((arrayValue, i) => querystringSingleKey(`${key}[${i}]`, arrayValue, keyPrefix))
            .join('&');
    }
    if (value instanceof Set) {
        const valueAsArray = Array.from(value);
        return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value instanceof Date) {
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
        return querystring(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
export function mapValues(data, fn) {
    return Object.keys(data).reduce((acc, key) => ({ ...acc, [key]: fn(data[key]) }), {});
}
export function canConsumeForm(consumes) {
    for (const consume of consumes) {
        if ('multipart/form-data' === consume.contentType) {
            return true;
        }
    }
    return false;
}
export class JSONApiResponse {
    raw;
    transformer;
    constructor(raw, transformer = (jsonValue) => jsonValue) {
        this.raw = raw;
        this.transformer = transformer;
    }
    async value() {
        return this.transformer(await this.raw.json());
    }
}
export class VoidApiResponse {
    raw;
    constructor(raw) {
        this.raw = raw;
    }
    async value() {
        return undefined;
    }
}
export class BlobApiResponse {
    raw;
    constructor(raw) {
        this.raw = raw;
    }
    async value() {
        return await this.raw.blob();
    }
    ;
}
export class TextApiResponse {
    raw;
    constructor(raw) {
        this.raw = raw;
    }
    async value() {
        return await this.raw.text();
    }
    ;
}
